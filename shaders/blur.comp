#version 460 core

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;
layout(std430, binding=1) buffer agentbufferblock { vec4 agentData[]; };

uniform float agentSpeed;

vec2 rotate(vec2 v, float a) {
	float s = sin(a);
	float c = cos(a);
	mat2 m = mat2(c, -s, s, c);
	return m * v;
}

// example shader that shows the agentbufferblock data being sent between gpu/cpu
void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 dims = vec2(imageSize(screen));
	int index = int(gl_GlobalInvocationID);

	// ---------- update agents ----------
	vec2 agentPosition = agentData[index].xy;
	vec2 agentDirection = agentData[index].zw;

	// ---------- sensing computations ----------
	float lookAheadDistance = 0.01;
	agentDirection = normalize(agentDirection);

	float fov = 0.8;
	float inertia = 20.0;

	vec2 lookAheadOffset1 = lookAheadDistance * rotate(agentDirection, 0.0);
	vec2 lookAheadOffset2 = lookAheadDistance * rotate(agentDirection, 0.5 * fov);
	vec2 lookAheadOffset3 = lookAheadDistance * rotate(agentDirection, -0.5 * fov);

	vec2 lookAheadPosition1 = lookAheadOffset1 + agentPosition;
	vec2 lookAheadPosition2 = lookAheadOffset2 + agentPosition;
	vec2 lookAheadPosition3 = lookAheadOffset3 + agentPosition;

	ivec2 lookAheadPixelLocation1 = ivec2(lookAheadPosition1 * dims);
	ivec2 lookAheadPixelLocation2 = ivec2(lookAheadPosition2 * dims);
	ivec2 lookAheadPixelLocation3 = ivec2(lookAheadPosition3 * dims);

	// assume x/y/z/w is all the same
	float lookAheadBrightness1 = imageLoad(screen, lookAheadPixelLocation1).x;
	float lookAheadBrightness2 = imageLoad(screen, lookAheadPixelLocation2).x;
	float lookAheadBrightness3 = imageLoad(screen, lookAheadPixelLocation3).x;

	agentDirection =
		lookAheadOffset1 * (lookAheadBrightness1 + inertia) +
		lookAheadOffset2 * lookAheadBrightness2 +
		lookAheadOffset3 * lookAheadBrightness3;

	agentDirection = normalize(agentDirection);

	agentData[index].zw = agentDirection;
	agentPosition += agentSpeed * agentDirection;
	agentData[index].xy = agentPosition;

	if (agentData[index].x > 1.0) {
		agentData[index].z *= -1.0;
	} else if (agentData[index].x < 0.0) {
		agentData[index].z *= -1.0;
	}

	if (agentData[index].y > 1.0) {
		agentData[index].w *= -1.0;
	} else if (agentData[index].y < 0.0) {
		agentData[index].w *= -1.0;
	}

	// ---------- drawing logic ----------
	// check that current shader's pixel is in vicinity of an agent
	bool nearAgent = false;
	float agentRadius = 2.5;
	int numAgents = 1024;
	for (int i = 0; i < numAgents; i++) {
		vec2 agentPosition = agentData[i].xy;
		vec2 agentDirection = agentData[i].zw;

		vec2 agentPixelCoords = agentPosition * dims;
		nearAgent = nearAgent || length(vec2(pixel_coords) - agentPixelCoords) < agentRadius;

		if (nearAgent) {
			break;
		}
	}

	vec4 pixel = vec4(0.0);
	if (nearAgent) {
		pixel = vec4(1.0);
	} else {
		// box blur
		pixel = vec4(0.0);
		for (int i = -1; i < 2; i++) {
			for (int j = -1; j < 2; j++) {
				ivec2 offset_coord = pixel_coords + ivec2(i, j);
				vec4 neighbour_pixel = imageLoad(screen, offset_coord);
				pixel += neighbour_pixel;
			}
		}
		pixel /= 9.0;
	}

	// dimming + set alpha channel to 1
	pixel -= vec4(0.005);
	pixel.w = 1.0;

	imageStore(screen, pixel_coords, pixel);
}