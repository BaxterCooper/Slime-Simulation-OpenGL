#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; // can be optimised

layout(rgba32f, binding = 0) uniform image2D image;
layout(std430, binding = 1) buffer agentPositionsBuffer { vec2 agentPositions[]; };
layout(std430, binding = 2) buffer agentDirectionsBuffer { vec2 agentDirections[]; };

uniform float agentMoveSpeed;
uniform float agentTurnSpeed;

uniform int sensorSize;
uniform float sensorOffset;
uniform float sensorFOV;

// uniform int time;

float rand(float n) {
	return fract(sin(n * 12.9898) * 43758.5453);
}

float rand(vec2 n) {
	return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
}

float noise(float p){
	float fl = floor(p);
	float fc = fract(p);
	return mix(rand(fl), rand(fl + 1.0), fc);
}

float noise(vec2 n) {
	const vec2 d = vec2(0.0, 1.0);
	vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
	return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
}

/*
 * IN RADIANS
 */
vec2 rotate(vec2 v, float a) {
	float s = sin(a);
	float c = cos(a);
	mat2 m = mat2(c, -s, s, c);
	return m * v;
}

/*
 * Required since negative pixelLocations are out of bounds
 * where x is the image dimensions... f: [-x, x] => [0, x]
 */
vec4 imageLookup(ivec2 pixelLocation) {
	vec2 dims = vec2(imageSize(image));
	return imageLoad(image, ivec2(0.5 * (pixelLocation + dims)));
}

/*
 * Computes total colour of a neighbourhood
 */
vec4 senseValue(ivec2 signedCentrePixelCoord) {
	vec4 sum = vec4(0.0);
	for (int i = -sensorSize; i <= sensorSize; i++) {
		for (int j = -sensorSize; j <= sensorSize; j++) {
			ivec2 pixelCoord = signedCentrePixelCoord + ivec2(i, j);
			sum += imageLookup(pixelCoord);
		}
	}

	return sum;
}

/* The attraction to a direction is a vector in that direction
 * with a magnitude equal to the colour (brightness) of the neighbourhood
 */
vec2 senseAttraction(vec2 agentPosition, vec2 senseCast) {
	vec2 dims = vec2(imageSize(image));
	vec2 offset = sensorOffset * senseCast;
	vec2 sensePosition = agentPosition + offset;
	ivec2 signedSensePixelPosition = ivec2(sensePosition * dims);
	float senseWeighting = senseValue(signedSensePixelPosition).r;
	vec2 attraction = senseCast * senseWeighting;
	return attraction;
}

/*
 * Computes the acceleration based on 3 regions of colour in front of the agent
 * Requires a low FOV for emergent properties (otherwise agents remain stationary)
 */
vec2 computeAcceleration(vec2 agentPosition, vec2 agentDirection) {
	// ------------------------------------------------------------------------
	// SENSE
	vec2 forwardCast = normalize(agentDirection);
	vec2 rightCast = rotate(agentDirection, -0.5 * sensorFOV);
	vec2 leftCast = rotate(agentDirection, 0.5 * sensorFOV);
	return (
		senseAttraction(agentPosition, forwardCast) +
		senseAttraction(agentPosition, rightCast) +
		senseAttraction(agentPosition, leftCast)
	);
}

void main() {
	int index = int(gl_GlobalInvocationID);

	vec2 agentPosition = agentPositions[index];
	vec2 agentDirection = agentDirections[index];

	vec2 dims = vec2(imageSize(image));
	ivec2 pixel_coords = ivec2(dims * agentPosition);

	// directionForward + directionRight + directionLeft;
	agentDirection += computeAcceleration(agentPosition, agentDirection);
	agentDirection = normalize(agentDirection);

	// -----------------------
	agentPosition = agentPosition + agentDirection * agentMoveSpeed;
	agentPositions[index] = agentPosition;

	// BOUNDARY CONDITION
	if (agentPosition.x > 1.0 || agentPosition.x < -1.0) {
		agentDirection.x *= -1.0;
	}

	if (agentPosition.y > 1.0 || agentPosition.y < -1.0) {
		agentDirection.y *= -1.0;
	}

	agentDirections[index] = agentDirection;
}
