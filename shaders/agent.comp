#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; // can be optimised

layout(rgba32f, binding = 0) uniform image2D image;
layout(std430, binding = 1) buffer agentPositionsBuffer { vec2 agentPositions[]; };
layout(std430, binding = 2) buffer agentDirectionsBuffer { vec2 agentDirections[]; };

uniform float agentMoveSpeed;
uniform float agentTurnSpeed;

uniform int sensorSize;
uniform float sensorOffset;
uniform float sensorFOV;


vec2 rotate(vec2 v, float a) {
	float s = sin(a);
	float c = cos(a);
	mat2 m = mat2(c, -s, s, c);
	return m * v;
}

float sense(ivec2 centrePixelCoord) {
	ivec2 dims = ivec2(imageSize(image));

	float sum = 0.0;
	for (int i = -sensorSize; i <= sensorSize; i++) {
		for (int j = -sensorSize; j <= sensorSize; j++) {
			ivec2 pixelCoord = centrePixelCoord + ivec2(i, j);

			if (pixelCoord.x >= 0 && pixelCoord.x <= dims.x && pixelCoord.y >= 0 && pixelCoord.y <= dims.y) {
				sum += imageLoad(image, pixelCoord).x;
			}
		}
	}

	return sum;
}

void main() {
	vec2 dims = vec2(imageSize(image));
	int index = int(gl_GlobalInvocationID);

	vec2 agentPosition = agentPositions[index];
	vec2 agentDirection = agentDirections[index];

	// ------------------------------------------------------------------------
	// SENSE

	// OFFSETS
	vec2 offsetForward = sensorOffset * agentDirection;
	vec2 offsetRight = sensorOffset * rotate(agentDirection, -0.5 * sensorFOV);
	vec2 offsetLeft = sensorOffset * rotate(agentDirection, 0.5 * sensorFOV);

	// POSITIONS
	vec2 positionForward = agentPosition + offsetForward;
	vec2 positionRight = agentPosition + offsetRight;
	vec2 positionLeft = agentPosition + offsetLeft;

	// COORDINATES
	ivec2 pixelCoordForward = ivec2((positionForward + 1.0) * dims * 0.5);
	ivec2 pixelCoordRight = ivec2((positionRight + 1.0) * dims * 0.5);
	ivec2 pixelCoordLeft = ivec2((positionLeft + 1.0) * dims * 0.5);

	// SENSING WEIGHTS
	float weightForward = sense(pixelCoordForward);
	float weightRight = sense(pixelCoordRight);
	float weightLeft = sense(pixelCoordLeft);

	// CHANGE DIRECTION 
	vec2 directionForward = agentDirection * weightForward;
	vec2 directionRight = weightRight * rotate(agentDirection, -0.5 * agentTurnSpeed * sensorFOV);
	vec2 directionLeft = weightLeft * rotate(agentDirection, 0.5 * agentTurnSpeed * sensorFOV);

	agentDirection += directionForward + directionRight + directionLeft;

	agentDirection = normalize(agentDirection);

	agentPosition = agentPosition + agentDirection * agentMoveSpeed;
	agentPositions[index] = agentPosition;

	// BOUNDARY CONDITION
	if (agentPosition.x > 1.0 || agentPosition.x < -1.0) {
		agentDirection.x *= -1.0;
	}

	if (agentPosition.y > 1.0 || agentPosition.y < -1.0) {
		agentDirection.y *= -1.0;
	}

	agentDirections[index] = agentDirection;
}
