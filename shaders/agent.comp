#version 460 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D image;
layout(std430, binding = 1) buffer agentPositionsBuffer { vec2 agentPositions[]; };
layout(std430, binding = 2) buffer agentDirectionsBuffer { vec2 agentDirections[]; };

uniform float agentSpeed;

vec2 rotate(vec2 v, float a) {
	float s = sin(a);
	float c = cos(a);
	mat2 m = mat2(c, -s, s, c);
	return m * v;
}

void main() {
	int index = int(gl_GlobalInvocationID);
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 dims = vec2(imageSize(image));

	vec2 agentPosition = agentPositions[index];
	vec2 agentDirection = agentDirections[index];

	// ---------- sensing computations ----------
	float lookAheadDistance = 0.01;
	agentDirection = normalize(agentDirection);

	float fov = 0.8;
	float inertia = 30.0;

	vec2 lookAheadOffset1 = lookAheadDistance * rotate(agentDirection, 0.0);
	vec2 lookAheadOffset2 = lookAheadDistance * rotate(agentDirection, 0.5 * fov);
	vec2 lookAheadOffset3 = lookAheadDistance * rotate(agentDirection, -0.5 * fov);

	vec2 lookAheadPosition1 = lookAheadOffset1 + agentPosition;
	vec2 lookAheadPosition2 = lookAheadOffset2 + agentPosition;
	vec2 lookAheadPosition3 = lookAheadOffset3 + agentPosition;

	ivec2 lookAheadPixelLocation1 = ivec2(lookAheadPosition1 * dims);
	ivec2 lookAheadPixelLocation2 = ivec2(lookAheadPosition2 * dims);
	ivec2 lookAheadPixelLocation3 = ivec2(lookAheadPosition3 * dims);

	// assume x/y/z/w is all the same
	float lookAheadBrightness1 = imageLoad(image, lookAheadPixelLocation1).x;
	float lookAheadBrightness2 = imageLoad(image, lookAheadPixelLocation2).x;
	float lookAheadBrightness3 = imageLoad(image, lookAheadPixelLocation3).x;

	agentDirection =
		lookAheadOffset1 * (lookAheadBrightness1 + inertia) +
		lookAheadOffset2 * lookAheadBrightness2 +
		lookAheadOffset3 * lookAheadBrightness3;

	agentDirection = normalize(agentDirection);

	agentPosition = agentPosition + agentDirection * agentSpeed;
	agentPositions[index] = agentPosition;

	if (agentPosition.x > 1.0) {
		agentDirection.x *= -1.0;
	} else if (agentPosition.x < -1.0) {
		agentDirection.x *= -1.0;
	}

	if (agentPosition.y > 1.0) {
		agentDirection.y *= -1.0;
	} else if (agentPosition.y < -1.0) {
		agentDirection.y *= -1.0;
	}

	agentDirections[index] = agentDirection;
}
