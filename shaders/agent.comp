#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; // can be optimised

layout(rgba32f, binding = 0) uniform image2D image;
layout(std430, binding = 1) buffer agentPositionsBuffer { vec2 agentPositions[]; };
layout(std430, binding = 2) buffer agentDirectionsBuffer { vec2 agentDirections[]; };

uniform float agentMoveSpeed;
uniform float agentTurnSpeed;

uniform int sensorSize;
uniform float sensorOffset;
uniform float sensorFOV;

vec2 rotate(vec2 v, float a) {
	float s = sin(a);
	float c = cos(a);
	mat2 m = mat2(c, -s, s, c);
	return m * v;
}

vec4 imageLookup(ivec2 pixelLocation) {
	vec2 dims = vec2(imageSize(image));
	return imageLoad(image, ivec2(0.5 * (pixelLocation + dims)));
}

vec4 sense(ivec2 centrePixelCoord) {
	vec4 sum = vec4(0.0);
	for (int i = -sensorSize; i <= sensorSize; i++) {
		for (int j = -sensorSize; j <= sensorSize; j++) {
			ivec2 pixelCoord = centrePixelCoord + ivec2(i, j);
			sum += imageLookup(pixelCoord);
		}
	}

	return sum;
}

void main() {
	int index = int(gl_GlobalInvocationID);

	vec2 agentPosition = agentPositions[index];
	vec2 agentDirection = agentDirections[index];

	vec2 dims = vec2(imageSize(image));
	ivec2 pixel_coords = ivec2(dims * agentPosition);

	// ------------------------------------------------------------------------
	// SENSE
	vec2 forwardCast = normalize(agentDirection);
	vec2 rightCast = rotate(agentDirection, -0.5 * sensorFOV);
	vec2 leftCast = rotate(agentDirection, 0.5 * sensorFOV);

	// OFFSETS
	vec2 offsetForward = sensorOffset * agentDirection;
	vec2 offsetRight = sensorOffset * rightCast;
	vec2 offsetLeft = sensorOffset * leftCast;

	// POSITIONS
	vec2 positionForward = agentPosition + offsetForward;
	vec2 positionRight = agentPosition + offsetRight;
	vec2 positionLeft = agentPosition + offsetLeft;

	// COORDINATES
	ivec2 pixelCoordForward = ivec2(positionForward * dims);
	ivec2 pixelCoordRight = ivec2(positionRight * dims);
	ivec2 pixelCoordLeft = ivec2(positionLeft * dims);

	// SENSING WEIGHTS
	float weightForward = sense(pixelCoordForward).x;
	float weightRight = sense(pixelCoordRight).x;
	float weightLeft = sense(pixelCoordLeft).x;

	// CHANGE DIRECTION 
	vec2 directionForward = agentDirection * weightForward;
	vec2 directionRight = weightRight * rightCast;
	vec2 directionLeft = weightLeft * leftCast;

	agentDirection += directionForward + directionRight + directionLeft;
	agentDirection = normalize(agentDirection);

	// -----------------------
	agentPosition = agentPosition + agentDirection * agentMoveSpeed;
	agentPositions[index] = agentPosition;

	// BOUNDARY CONDITION
	if (agentPosition.x > 1.0 || agentPosition.x < -1.0) {
		agentDirection.x *= -1.0;
	}

	if (agentPosition.y > 1.0 || agentPosition.y < -1.0) {
		agentDirection.y *= -1.0;
	}

	agentDirections[index] = agentDirection;
}
