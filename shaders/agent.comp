#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; // can be optimised

layout(rgba32f, binding = 0) uniform image2D image;
layout(std430, binding = 1) buffer agentPositionsBuffer { vec2 agentPositions[]; };
layout(std430, binding = 2) buffer agentDirectionsBuffer { vec2 agentDirections[]; };

uniform float agentMoveSpeed;
uniform float agentTurnSpeed;

uniform int sensorSize;
uniform float sensorOffset;
uniform float sensorFOV;


vec2 rotate(vec2 v, float a) {
	float s = sin(a);
	float c = cos(a);
	mat2 m = mat2(c, -s, s, c);
	return m * v;
}

vec4 sense(ivec2 centrePixelCoord) {
	vec4 sum = vec4(0.0);
	for (int i = -sensorSize; i <= sensorSize; i++) {
		for (int j = -sensorSize; j <= sensorSize; j++) {
			ivec2 pixelCoord = centrePixelCoord + ivec2(i, j);
			sum += imageLoad(image, pixelCoord);
		}
	}

	return sum;
}

float rand(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}


void main() {
	vec2 dims = vec2(imageSize(image));
	int index = int(gl_GlobalInvocationID);

	vec2 agentPosition = agentPositions[index];
	vec2 agentDirection = agentDirections[index];

	float random = rand(agentPosition * agentDirection * index);

	// ------------------------------------------------------------------------
	// SENSE

	// OFFSETS
	vec2 offsetForward = sensorOffset * agentDirection;
	vec2 offsetRight = sensorOffset * rotate(agentDirection, -0.5 * sensorFOV);
	vec2 offsetLeft = sensorOffset * rotate(agentDirection, 0.5 * sensorFOV);

	// POSITIONS
	vec2 positionForward = agentPosition + offsetForward;
	vec2 positionRight = agentPosition + offsetRight;
	vec2 positionLeft = agentPosition + offsetLeft;

	// COORDINATES
	ivec2 pixelCoordForward = ivec2((positionForward + 1.0) * dims * 0.5);
	ivec2 pixelCoordRight = ivec2((positionRight + 1.0) * dims * 0.5);
	ivec2 pixelCoordLeft = ivec2((positionLeft + 1.0) * dims * 0.5);

	// SENSING WEIGHTS
	float weightForward = sense(pixelCoordForward).x * 0.1;
	float weightRight = sense(pixelCoordRight).x;
	float weightLeft = sense(pixelCoordLeft).x;

	// CHANGE DIRECTION 
	vec2 directionForward = agentDirection * weightForward;
	vec2 directionRight = weightRight * rotate(agentDirection, -0.5 * agentTurnSpeed * sensorFOV);
	vec2 directionLeft = weightLeft * rotate(agentDirection, 0.5 * agentTurnSpeed * sensorFOV);

	agentDirection += directionForward + directionRight + directionLeft;

	agentDirection = normalize(agentDirection);

	agentPosition = agentPosition + (agentDirection / dims) * agentMoveSpeed;
	agentPositions[index] = agentPosition;

	// BOUNDARY CONDITION
	if (agentPosition.x > 1.0 || agentPosition.x < -1.0) {
		agentDirection.x *= -1.0;
		agentDirection.y = random * 2.0 - 1.0;
	}

	if (agentPosition.y > 1.0 || agentPosition.y < -1.0) {
		agentDirection.y *= -1.0;
		agentDirection.x = random * 2.0 - 1.0;
	}

	agentDirections[index] = agentDirection;
}
